# P3903 导弹拦截III

## 题目描述

很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。

这个系统可以发射一颗导弹拦截从由到远、高度不增加的多个导弹。

但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。

这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。

当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。

现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。

## 输入格式

第一行是一个整数 $n$，表示敌人发射的导弹数目。接下来的一行有 $n$ 个整数，表示由近到远的。

## 输出格式

仅一个整数，表示拦截的最多导弹的数量。

## 输入输出样例 #1

### 输入 #1

```
4
5 3 2 4
```

### 输出 #1

```
3
```

## 说明/提示

$1\leq n\leq 10^3$，$1\leq $ 导弹高度 $\leq 10^9$。

```
#include<iostream>
using namespace std;
typedef long long ll;
const ll N = 1e3 + 5;
ll n, a[N],dp[N];//以第i个导弹结尾的可以拦截的最大长度
void slove()
{
  cin>>n;
  for (int i = 1;i<=n;i++)
  {
    cin >> a[i];
    dp[i] = 1;
  }

  ll ans = 1;//拦截第ans个
  for (int i = 1; i <= n;i++)
  {
    for (int j = 1; j < i;j++)
    {
      if(dp[j]%2==1)//第奇数个
      {
        if(a[i]<a[j])//那么这次是第偶数个
        {
          dp[i] = max(dp[i], dp[j] + 1);
        }
      }
      else if(dp[j]%2==0)
      {
        if(a[i]>a[j])
        {
          dp[i] = max(dp[i], dp[j] + 1);
        }
      }
    }
  }

  ll maxlen=0;
  for (int i = 1;i<=n;i++)maxlen=max(maxlen,dp[i]);
  cout << maxlen;
}

signed main()
{
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  slove();
  return 0;
}
```
