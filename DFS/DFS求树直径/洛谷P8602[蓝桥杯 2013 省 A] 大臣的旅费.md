# P8602 [蓝桥杯 2013 省 A] 大臣的旅费

## 题目描述

很久以前，T 王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T 国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J 是 T 国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了 J 最常做的事情。他有一个钱袋，用于存放往来城市间的路费。

聪明的 J 发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第 $x - 1$ 千米到第 $x$ 千米这一千米中（x 是整数），他花费的路费是 $x+10$ 这么多。也就是说走 $1$ 千米花费 $11$，走 $2$ 千米要花费 $23$。

J 大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

## 输入格式

输入的第一行包含一个整数 $n(n \le 10^5)$，表示包括首都在内的 $T$ 王国的城市数。

城市从 $1$ 开始依次编号，1 号城市为首都。

接下来 $n-1$ 行，描述 $T$ 国的高速路（T 国的高速路一定是 $n-1$ 条）。

每行三个整数 $P_i,Q,D_i$，表示城市 $P_i$ 和城市 $Q_i$ 之间有一条高速路，长度为 $D_i(D_i \le 1000)$ 千米。

## 输出格式

输出一个整数，表示大臣J最多花费的路费是多少。

## 输入输出样例 #1

### 输入 #1

```
5
1 2 2
1 3 1
2 4 5
2 5 4
```

### 输出 #1

```
135
```

## 说明/提示

样例解释：大臣 J 从城市 $4$ 到城市 $5$ 要花费 $135$ 的路费。

时限 5 秒, 64M。蓝桥杯 2013 年第四届省赛


AC代码:
```
#include <iostream>
#include <vector>
#include<cstring>
using namespace std;
int n, p, q, d;
bool vis[1000005];     // i节点是否走过
long long dis[100005]; // 到i节点的距离
class node
{
public:
    int id, st; // 到此节点的距离
};
vector<node> h[100005];

void dfs(int t)
{
    // 搜寻这个节点能到达的所有节点
    for (int i = 0; i < h[t].size(); i++)
    {
        int tt = h[t][i].id;
        if (!vis[tt])
        {
            vis[tt] = 1;
            dis[tt] = dis[t] + h[t][i].st;
            dfs(tt);
        }
    }
}

int main()
{
    cin >> n;
    for (int i = 1; i < n; i++)
    {
        cin >> p >> q >> d;
        h[p].push_back({q, d});
        h[q].push_back({p, d});
    }

    //随意从一个点出发 这里我们就从1节点出发就行
    vis[1]=1;
    dfs(1); // 当前在第一个节点
    int Q;//直径的一个端点
    long long maxx = -1;
    for (int i = 1; i <= n;i++)
    {
        if(dis[i]>maxx)
        {
            maxx = max(maxx, dis[i]);
            Q = i;
        }
    }
    //找完Q端点后 继续找另一端的端点
    memset(dis, 0, sizeof(dis));
    memset(vis, 0, sizeof(vis));

    vis[Q] = 1;
    dfs(Q);
    int P;//直径的另一端
    maxx = -1;
    for (int i = 1; i <= n; i++)
    {
        if (dis[i] > maxx)
        {
            maxx = max(maxx, dis[i]);
            P = i;
        }
    }
    
    //此时maxx为直径
    cout << ((11 + (maxx + 10)) * maxx) / 2;

    return 0;
}
```
思路分析：https://blog.csdn.net/2401_87117051/article/details/145579428
